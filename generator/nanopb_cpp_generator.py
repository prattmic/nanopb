#!/usr/bin/env python

import argparse
import os.path
import sys

import generator.nanopb_generator as nanopb

def generate_string_methods(args, message, field, is_optional):
    args.output.write("""
    const char *get_{field}() const {{
        return {field};
    }}
""".format(field=field.name))

    if is_optional:
        args.output.write("""
    // TODO(prattmic): rename to has_{field}
    // has_{field} is taken by the base type :(
    bool present_{field}() const {{
        return has_{field};
    }}

    void set_{field}(const char *val) {{
        strncpy({field}, val, {max_size});
        {field}[{max_size}-1] = '\\0';
        has_{field} = true;
    }}

    void clear_{field}() {{
        has_{field} = false;
        strncpy({field}, nanopb::{message}_init_default.{field}, {max_size});
    }}
""".format(message=message.name, field=field.name, max_size=field.max_size))
    else:
        args.output.write("""
    bool present_{field}() const {{
        return true;
    }}

    void set_{field}(const char *val) {{
        strncpy({field}, val, {max_size});
        {field}[{max_size}-1] = '\\0';
    }}

    void clear_{field}() {{
        strncpy({field}, nanopb::{message}_init_default.{field}, {max_size});
    }}
""".format(message=message.name, field=field.name, type=field_type))

def generate_class(args, message):
    name = message.name
    base = "nanopb::%s" % name

    args.output.write("class %s : public %s {\n" % (name, base))

    # Common code
    args.output.write("""
    using _base = {base};

 public:
    // Default constructor.
    {name}() {{
        *static_cast<_base*>(this) = nanopb::{name}_init_default;
    }}

    // Copy constructor from base type.
    explicit {name}(const _base& v) {{
        *this = static_cast<const {name}&>(v);
    }}

    // Deserialize from a buffer.
    static ::util::StatusOr<{name}> Deserialize(uint8_t *buffer, int size) {{
        {name} msg;
        nanopb::pb_istream_t stream = nanopb::pb_istream_from_buffer(buffer, size);
        if (!nanopb::pb_decode(&stream, nanopb::{name}_fields, &msg)) {{
            return ::util::Status(::util::error::Code::UNKNOWN, PB_GET_ERROR(&stream));
        }}
        return msg;
    }}

    // Serialize to a buffer. Returns bytes written to buffer.
    ::util::StatusOr<size_t> Serialize(uint8_t *buffer, int size) {{
        nanopb::pb_ostream_t stream = nanopb::pb_ostream_from_buffer(buffer, size);
        if (!nanopb::pb_encode(&stream, nanopb::{name}_fields, this)) {{
            return ::util::Status(::util::error::Code::UNKNOWN, PB_GET_ERROR(&stream));
        }}
        return stream.bytes_written;
    }}

""".format(name=name, base=base))

    for field in message.fields:
        if field.allocation != 'STATIC' or field.allocation == 'CALLBACK':
            raise NotImplementedError(
                "Field %s has unsupported allocation '%s'" \
                    % (field.name, field.allocation))
            continue
        if field.array_decl and field.pbtype != 'STRING':
            raise NotImplementedError(
                "Field %s has unsupported array_decl %s" \
                    % (field.name, field.array_decl))

        is_enum = field.pbtype in ("ENUM", "UENUM")
        is_string = field.pbtype == "STRING"
        is_optional = field.rules == "OPTIONAL"

        field_type = str(field.ctype)
        if is_enum:
            # We don't redefine these, so they come from nanopb directly.
            field_type = "nanopb::"+field_type

        # Strings are special, so they get special handling.
        if is_string:
            generate_string_methods(args, message, field, is_optional)
            continue

        args.output.write("""
    {type} get_{field}() const {{
        return {type}({field});
    }}
""".format(field=field.name, type=field_type))

        if is_optional:
            args.output.write("""
    // TODO(prattmic): rename to has_{field}
    // has_{field} is taken by the base type :(
    bool present_{field}() const {{
        return has_{field};
    }}

    void set_{field}({type} val) {{
        {field} = val;
        has_{field} = true;
    }}

    void clear_{field}() {{
        has_{field} = false;
        {field} = nanopb::{message}_init_default.{field};
    }}
""".format(message=message.name, field=field.name, type=field_type))
        else:
            args.output.write("""
    bool present_{field}() const {{
        return true;
    }}

    void set_{field}({type} val) {{
        {field} = val;
    }}

    void clear_{field}() {{
        {field} = nanopb::{message}_init_default.{field};
    }}
""".format(message=message.name, field=field.name, type=field_type))

    args.output.write("};\n\n")

def generate(args, proto):
    args.output.write('''//  AUTOGENERATED - DO NOT EDIT
#include <stdint.h>
#include <string.h>
#include "pb_encode.h"
#include "pb_decode.h"
#include "util/task/statusor.h"
#include "{include}"

'''.format(include=args.include))

    messages = list(nanopb.sort_dependencies(proto.messages))

    for m in messages:
        generate_class(args, m)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generate nanopb C++ bindings')
    parser.add_argument('file', help='file to parse')
    parser.add_argument('-o', '--output', type=argparse.FileType('w'),
                        default=sys.stdout, help='output file')
    parser.add_argument('--include', default=None,
                        help='base nanopb header include path. defaults to PROTO.pb.h.')

    # Note: the first arg without switches (- or --) will be treated as 'file',
    # so switches to be passed to nanopb.optparse should be in the form
    # '--arg=val' rather than '--arg val'.
    args, unknown = parser.parse_known_args()
    if args.include is None:
        args.include = "%s.pb.h" % (os.path.splitext(args.file)[0])

    options, _ = nanopb.optparser.parse_args(unknown)
    proto = nanopb.parse_file(args.file, None, options)

    generate(args, proto)
